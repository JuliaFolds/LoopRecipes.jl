var documenterSearchIndex = {"docs":
[{"location":"#LoopRecipes.jl","page":"LoopRecipes.jl","title":"LoopRecipes.jl","text":"","category":"section"},{"location":"","page":"LoopRecipes.jl","title":"LoopRecipes.jl","text":"","category":"page"},{"location":"","page":"LoopRecipes.jl","title":"LoopRecipes.jl","text":"Modules = [LoopRecipes]\nPrivate = false","category":"page"},{"location":"#LoopRecipes.LoopRecipes","page":"LoopRecipes.jl","title":"LoopRecipes.LoopRecipes","text":"LoopRecipes: composable loops\n\n(Image: Dev) (Image: GitHub Actions)\n\nLoopRecipes.jl provides several constructs for high-performance loops based on the extended foldl protocol of Transducers.jl.\n\nSee more in the documentation.\n\nAPI summary\n\nunroll(factor, xs): Unroll an array xs by a given factor.\nprefetching(xs): Prefetch each element in xs.  It works when xs is a nested data structure (e.g., vector of vectors, vector of strings).\nsimdeachindex([width,] xs): Iterate over indices of xs using SIMD.VecRange.  It also takes care of the remainder loop.\nsimdpairs([width,] xs): Iterate over index-value pairs of xs using SIMD.VecRange and SIMD.Vec.  It also takes care of the remainder loop.\nsimdstored([width,] xs): For a sparse array xs, iterate over stored index-value pairs of xs using SIMD.Vec.  It also takes care of the remainder loop.\n\n\n\n\n\n","category":"module"},{"location":"#LoopRecipes.prefetching-Tuple{Any}","page":"LoopRecipes.jl","title":"LoopRecipes.prefetching","text":"prefetching(xs)\n\nPrefetch each boxed element in xs.  It can be used when xs is a nested data structure (e.g., vector of vectors, vector of strings). Do nothing when the element of xs is not boxed.\n\nExamples\n\njulia> using LoopRecipes\n\njulia> sum(sum, prefetching([[1], [2, 3], [4, 5, 6]]))\n21\n\njulia> using FLoops\n\njulia> @floop begin\n           acc = 0\n           for x in prefetching([[1], [2, 3], [4, 5, 6]])\n               acc += sum(x)\n           end\n           acc\n       end\n21\n\n\n\n\n\n","category":"method"},{"location":"#LoopRecipes.simdeachindex-Tuple{Any}","page":"LoopRecipes.jl","title":"LoopRecipes.simdeachindex","text":"simdeachindex([width,] xs)\n\nReturn a foldable that iterates over indices of xs using SIMD.VecRange and/or integer.\n\nwidth is an integer or a Val of integer that specifies the SIMD width.\n\nExamples\n\njulia> using LoopRecipes\n\njulia> foreach(simdeachindex(4, ones(10))) do i\n           @show i\n       end;\ni = VecRange{4}(1)\ni = VecRange{4}(5)\ni = 9\ni = 10\n\n\n\n\n\n","category":"method"},{"location":"#LoopRecipes.simdpairs-Tuple{Any}","page":"LoopRecipes.jl","title":"LoopRecipes.simdpairs","text":"simdpairs([width,] xs)\n\nReturn a foldable that iterates over index-value pairs of xs using SIMD.VecRange and SIMD.Vec for the main part.\n\nwidth is an integer or a Val of integer that specifies the SIMD width.\n\nSee also simdeachindex.\n\nExamples\n\njulia> using LoopRecipes\n\njulia> foreach(simdpairs(4, collect(100:100:1000))) do (i, v)\n           @show i v\n       end;\ni = VecRange{4}(1)\nv = <4 x Int64>[100, 200, 300, 400]\ni = VecRange{4}(5)\nv = <4 x Int64>[500, 600, 700, 800]\ni = 9\nv = 900\ni = 10\nv = 1000\n\nThanks to setindex! overload on VecRange, it is straightforward to use it for implementing a simple mapping.\n\njulia> function double!(ys, xs)\n           @assert axes(ys) == axes(xs)\n           foreach(simdpairs(xs)) do (i, x)\n               @inbounds ys[i] = 2x\n           end\n           return ys\n       end;\n\njulia> double!(zeros(5), ones(5))\n5-element Array{Float64,1}:\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n\nWhen using simdpairs for reduction, the accumulator acc should be properly reduced depending on the type of v.  This is because the same loop body (aka op or rf) is used for all stages of the iteration.\n\njulia> using SIMD  # for Vec\n\njulia> foldl(simdpairs(collect(1:10)); init = 0) do acc, (_, v)\n           x = 2 * v\n           (v isa Vec ? acc : sum(acc)) + x\n       end\n110\n\nHere is another example for demonstrating how v isa Vec works:\n\njulia> foldl(simdpairs(4, collect(10:24)); init = 0) do acc, (i, v)\n           @show first(i), acc, v\n           (v isa Vec ? acc : sum(acc)) + v\n       end\n(first(i), acc, v) = (1, 0, <4 x Int64>[10, 11, 12, 13])\n(first(i), acc, v) = (5, <4 x Int64>[10, 11, 12, 13], <4 x Int64>[14, 15, 16, 17])\n(first(i), acc, v) = (9, <4 x Int64>[24, 26, 28, 30], <4 x Int64>[18, 19, 20, 21])\n(first(i), acc, v) = (13, <4 x Int64>[42, 45, 48, 51], 22)\n(first(i), acc, v) = (14, 208, 23)\n(first(i), acc, v) = (15, 231, 24)\n255\n\nObserve that:\n\n(1) When at the first iteration (first(i) == 1), acc is 0 (as specified by init = 0).  This is broadcast to a Vec because v is a Vec.  See that acc in the second iteration (first(i) == 5) is a Vec (<4 x Int64>[10, 11, 12, 13]).\n\n(2) At the second and third iterations, both acc and v are Vec, yielding an acc::Vec for the next iteration.\n\n(3) At the iteration first(i) == 13, v is not Vec (i.e., we are in the reminder loop).  Thus, acc (<4 x Int64>[42, 45, 48, 51]) is reduced a scalar before adding v (22).  See that acc in the next iteration is a scalar (208).\n\n(4) Final two iterations deals with scalar acc and v.  Note that we do not need a special code since sum(::Number) is an identity function.\n\nnote: Note\nSince simdeachindex and thus simdpairs uses Transducers.__foldl__ instead of Base.iterate to implement the iteration, these four stages are all properly type-stabilized.\n\nThese may look complicated but the rule is simple: the returned value of the reducing function (i.e., accumulation result) should have the same \"shape\" as the input value v.\n\n\n\n\n\n","category":"method"},{"location":"#LoopRecipes.simdstored-Tuple{Any}","page":"LoopRecipes.jl","title":"LoopRecipes.simdstored","text":"simdstored([width,] xs)\n\nReturn a foldable that iterates over stored index-value pairs of xs using SIMD.Vec for the main part.\n\nwidth is an integer or a Val of integer that specifies the SIMD width.\n\nExamples\n\nFor dense arrays, simdstored is identical to simdpairs:\n\njulia> using LoopRecipes\n\njulia> foreach(simdstored(4, collect(1:10))) do (i, v)\n           @show i v\n       end;\ni = VecRange{4}(1)\nv = <4 x Int64>[1, 2, 3, 4]\ni = VecRange{4}(5)\nv = <4 x Int64>[5, 6, 7, 8]\ni = 9\nv = 9\ni = 10\nv = 10\n\nFor parse arrays, simdstored iterates over only stored index-value pairs:\n\njulia> using SparseArrays\n\njulia> xs = SparseVector(10, [1, 3, 4, 7, 8], [1, 2, 3, 4, 5]);\n\njulia> foreach(simdstored(4, xs)) do (i, v)\n           @show i v\n       end;\ni = <4 x Int64>[1, 3, 4, 7]\nv = <4 x Int64>[1, 2, 3, 4]\ni = 8\nv = 5\n\nLike simdpairs, the accumulator acc should be properly reduced depending on the type of v:\n\njulia> using SIMD  # for Vec\n\njulia> foldl(simdstored(xs); init = 0) do acc, (_, v)\n           x = 2 * v\n           (v isa Vec ? acc : sum(acc)) + x\n       end\n30\n\nSparse-dense dot product:\n\njulia> function simddot(xs::SparseVector, ys)\n           init = zero(eltype(xs)) * zero(eltype(ys))\n           foldl(simdstored(xs); init = init) do acc, (i, x)\n               Base.@_inline_meta\n               (x isa Vec ? acc : sum(acc)) + @inbounds x * ys[i]\n           end\n       end;\n\njulia> simddot(xs, [1:10;])\n87\n\nIdentical function written using FLoops.jl:\n\njulia> using FLoops\n\njulia> function simddot′(xs::SparseVector, ys)\n           @floop begin\n               acc = zero(eltype(xs)) * zero(eltype(ys))\n               for (i, x) in simdstored(xs)\n                   acc = (x isa Vec ? acc : sum(acc)) + @inbounds x * ys[i]\n               end\n               acc\n           end\n       end;\n\njulia> simddot′(xs, [1:10;])\n87\n\n\n\n\n\n","category":"method"},{"location":"#LoopRecipes.unroll","page":"LoopRecipes.jl","title":"LoopRecipes.unroll","text":"unroll(factor, xs)\nunroll(factor, indexstyle, xs)\n\nUnroll an array xs by a given factor (an integer or a Val of integer).\n\nExamples\n\njulia> using LoopRecipes\n\njulia> sum(unroll(4, 1:10))\n55\n\njulia> sum(unroll(Val(4), 1:10))  # equivalent\n55\n\njulia> using FLoops\n\njulia> @floop begin\n           acc = 0\n           for x in unroll(4, 1:10)\n               acc += x\n           end\n           acc\n       end\n55\n\n\n\n\n\n","category":"function"}]
}
